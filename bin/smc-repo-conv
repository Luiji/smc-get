# -*- coding: utf-8 -*-
#!/usr/bin/env ruby

require "open-uri"
require "fileutils"
require "pathname"
require "tempfile"
require "psych"
require "yaml"
require_relative "../lib/smc_get"

PROGNAME = File.basename($0)

if ARGV.empty? or ARGV.include?("-h") or ARGV.include?("--help")
  puts(<<HELP)
USAGE:
  #{PROGNAME} OUTPUT_DIRECTORY

Skims through the GitHub SMC repository that contains all source
files for the SMCPAK files in the main repository and converts
them all to SMCPAKs. A complete SMC repository is created inside
OUTPUT_DIRECTORY.
HELP
exit
end

OUTPUT_DIRECTORY   = Pathname.new(ARGV.pop)
SPECS_DIRECTORY    = OUTPUT_DIRECTORY + "specs"
PACKAGES_DIRECTORY = OUTPUT_DIRECTORY + "packages"

SOURCE_REPO_BASE_URL = "https://raw.github.com/Luiji/Secret-Maryo-Chronicles-Contributed-Levels/master"
SPECS_BASE_URL       = SOURCE_REPO_BASE_URL + "/packages/"
PACKAGE_LIST_URL     = SPECS_BASE_URL + "packages.lst"
ELEMENT_BASE_URLS    = {
  :levels   => SOURCE_REPO_BASE_URL + "/levels/",
  :graphics => SOURCE_REPO_BASE_URL + "/graphics/",
  :music    => SOURCE_REPO_BASE_URL + "/music/",
  :sounds   => SOURCE_REPO_BASE_URL + "/sounds/",
  :worlds   => SOURCE_REPO_BASE_URL + "/worlds/"
}

ELEMENT_TEMP_DIRS = {
  :levels   => "levels",
  :graphics => "pixmaps",
  :music    => "music",
  :sounds   => "sounds",
  :worlds   => "worlds"
}

########################################
# Start of code
########################################

@output_mutex = Mutex.new
@threads = []
Thread.abort_on_exception = true

def info(str)
  @output_mutex.synchronize do
    puts(str) #TODO: Handling the --quiet option!
  end
end

def error(str)
  @output_mutex.synchronize do
    $stderr.puts(str)
  end
end

def make_spec(name, old_spec, directory)
  new_spec = old_spec.dup
  new_spec["checksums"] = Hash.new{|hsh, k| hsh[k] = Hash.new(&hsh.default_proc)} #Recursive hash

  %w[levels graphics music sounds].each do |str|
    old_spec[str].each do |file|
      file = Pathname.new(file)
      hsh = new_spec["checksums"][str]
      file.parent.each_filename{|part| hsh = hsh[part]} #Recursively grabbing second-to-last item
      checksum = Digest::SHA1.file(directory + ELEMENT_TEMP_DIRS[str] + file).hexdigest
      hsh[file.basename.to_s] = checksum
    end
  end

  old_spec["worlds"].each do |worldname|
    %w[description.xml layer.xml world.xml].each do |filename|
      checksum = Digest::SHA1.file(directory + worldname + filename).hexdigest
      new_spec["checksums"]["worlds"][worldname][filename] = checksum
    end
  end

  File.open(directory + "#{name}.yml", "w"){|f| YAML.dump(new_spec, f)}
end

def makepkg(directory)

end

include FileUtils::Verbose #We want to see what’s going on

rm_rf OUTPUT_DIRECTORY
mkdir_p OUTPUT_DIRECTORY
mkdir PACKAGES_DIRECTORY
mkdir SPECS_DIRECTORY

#Get the list of all available packages
info("Reading remote package list")
package_names = open(PACKAGE_LIST_URL){|page| page.readlines.map(&:chomp)}

#Iterate through all the packages
package_names.each do |pkgname|
  #To speed up the whole thing, do each package in it’s own thread
  @threads << Thread.new do
    #Get the remote package spec
    info("Reading remote package specification for '#{pkgname}'")
    spec_url = SPECS_BASE_URL + "#{pkgname}.yml"
    spec = open(spec_url){|page| YAML.load(page)}

    #Create a temporary directory just for this sole package
    Dir.mktmpdir do |tmpdir|
      tmpdir = Pathname.new(tmpdir)
      
      begin
        #Download all the package’s files into the appropriate directories
        [:levels, :graphics, :music, :sounds].each do |sym|
          next unless spec[sym.to_s] #Not all specs contain everything
          info("Downloading #{sym} for '#{pkgname}'")
          
          spec[sym.to_s].each do |file|
            file = Pathname.new(file)
            downloaded_file = tmpdir + ELEMENT_TEMP_DIRS[sym] + file
            mkdir_p downloaded_file.dirname #Subdirectories usually allowed
            
            open(ELEMENT_BASE_URLS[sym] + URI.escape(file.to_s)) do |page| 
              File.open(downloaded_file, "w"){|f| f.write(page.read)}
            end #open URI
          end #each file
        end #each symbol

        info("Computing checksums for '#{pkgname}'")
        make_spec(pkgname, spec, tmpdir)
        info("Copying '#{pkgname}' to '#{OUTPUT_DIRECTORY}'")
        pkg = SmcGet::Package.create(tmpdir)
        cp pkg.path, PACKAGES_DIRECTORY
        pkg.spec.save(SPECS_DIRECTORY)
      rescue => e
        error("Skipping package '#{pkgname}', original error was: #{e.message}")
      end
    end #mktmpdir
    
  end #Thread.new
end #package_names.each
info("MAIN PROGRAM FINISHED") #DEBUG
@threads.map(&:join)
sleep #DEBUG
